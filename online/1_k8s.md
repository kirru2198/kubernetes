# Kubernetes Recap & Rolling Updates   
**Topic:** Kubernetes Architecture, Objects, EKS Setup, and Rolling Updates

---

## 📌 Topics Covered

### 1. **Kubernetes Architecture Overview**

Kubernetes has two primary layers:

#### **Control Plane**
Manages the overall cluster state.
- **kube-apiserver**: Acts as a communication hub; all components interact through it.
- **controller-manager**: Ensures that the current state matches the desired state.
- **scheduler**: Decides which pod should be placed on which node.
- **etcd**: A distributed key-value store used as Kubernetes' backing store for all cluster data.
> etcd: It's like a super-powered notepad that Kubernetes uses to keep track of everything happening in the cluster—like which pods are running, configurations, secrets, and more. It stores all this information in a safe and reliable way, so Kubernetes always knows the current state of the system.

#### **Data Plane (Worker Nodes)**
Where application workloads run.
- **kubelet**: Agent that runs on each node, communicates with the API server.
- **container runtime**: Software like Docker or containerd to run containers.
- **kube-proxy**: Manages network rules and enables communication across services and pods.
> kube-proxy: Think of it as the traffic manager for your cluster. It helps your apps (pods and services) talk to each other by setting up the right network routes and making sure requests get to the right place.

---

### 2. **Key Kubernetes Objects**

- **Pod**: The smallest deployable unit in Kubernetes, representing a single instance of a running process.
> **Pod**: It's the smallest piece you can run in Kubernetes. You can think of it like a tiny box that holds your app (or part of it) and runs it. Each pod usually runs one container, and it's where your code actually lives and works inside the cluster.

- **ReplicaSet**: Maintains a stable set of replica Pods running at any given time.
  > ReplicaSet: Makes sure the right number of copies (replicas) of your pods are always running. If one goes down, it quickly brings up another to keep things running smoothly.
  - Automatically creates new Pods if existing ones are deleted.

---

### 3. **Demonstration Recap**

You created a **2-node EKS cluster** with the following steps:

#### ✅ **EKS Setup**
1. Created an EC2 instance.
2. Installed required tools:
   - `awscli`
   - `eksctl`
   - `kubectl`
3. Assigned IAM role to EC2.
4. Created cluster using:
   ```bash
   eksctl create cluster --name <cluster-name> --region <region> --node-type <instance-type>
   ```
5. Verified cluster creation using:
   ```bash
   kubectl get nodes
   ```

#### 🧩 **Cluster Structure**
- AWS manages the control plane.
- You connected via the EC2 instance to interact with the cluster.
- Pods are launched on worker nodes.

---

### 4. **Pods vs ReplicaSet**

- When a **Pod** is deleted manually, it doesn’t come back.
- When a **ReplicaSet** is used, it maintains the desired count.  
  E.g., If 3 Pods are desired and 1 is deleted, a new one is automatically created.

---

### 5. **Deploying Applications in Kubernetes**

To deploy an application:
1. **Write application code**
2. **Create Dockerfile**
3. **Build Docker image**
4. **Reference image in Kubernetes Pod config**
  > Reference image in Kubernetes Pod config means telling Kubernetes which **Docker image** to use when creating the container inside the pod. It’s like giving it the recipe to know what app to run.
5. **Deploy using `kubectl apply`**

---

### 6. **Application Upgrade Strategy**

Let’s say we have:

- **App Version 1.0**
- Code → Dockerfile → Docker Image → Pod (3 replicas)

Now, you update the code (e.g., to Version 1.1), so:
- New code → New Dockerfile → New Image → New Pod

#### ❌ **Bad Practice:**
Deleting old pods and applying new ones causes **downtime**.

---

### ✅ **Solution: Rolling Updates**

**Rolling Update** allows **zero-downtime deployments** by:
- Gradually replacing old Pods with new ones.
- Ensuring some instances of the app are always running.

---

## 🔜 What’s Next?

- Dive deeper into **Kubernetes Networking**
- Explore **etcd** in more detail
- Learn how **Rolling Updates** work with `Deployment` objects
- Possibly set up a **CI/CD pipeline** for automatic rolling updates

---
