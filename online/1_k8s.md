# Kubernetes Recap & Rolling Updates   
**Topic:** Kubernetes Architecture, Objects, EKS Setup, and Rolling Updates

---

## 📌 Topics Covered

### 1. **Kubernetes Architecture Overview**

Kubernetes has two primary layers:

#### **Control Plane**
Manages the overall cluster state.
- **kube-apiserver**: Acts as a communication hub; all components interact through it.
- **controller-manager**: Ensures that the current state matches the desired state.
- **scheduler**: Decides which pod should be placed on which node.
- **etcd**: A distributed key-value store used as Kubernetes' backing store for all cluster data.
> etcd: It's like a super-powered notepad that Kubernetes uses to keep track of everything happening in the cluster—like which pods are running, configurations, secrets, and more. It stores all this information in a safe and reliable way, so Kubernetes always knows the current state of the system.

#### **Data Plane (Worker Nodes)**
Where application workloads run.
- **kubelet**: Agent that runs on each node, communicates with the API server.
- **container runtime**: Software like Docker or containerd to run containers.
- **kube-proxy**: Manages network rules and enables communication across services and pods.
> kube-proxy: Think of it as the traffic manager for your cluster. It helps your apps (pods and services) talk to each other by setting up the right network routes and making sure requests get to the right place.

---

### 2. **Key Kubernetes Objects**

- **Pod**: The smallest deployable unit in Kubernetes, representing a single instance of a running process.
> **Pod**: It's the smallest piece you can run in Kubernetes. You can think of it like a tiny box that holds your app (or part of it) and runs it. Each pod usually runs one container, and it's where your code actually lives and works inside the cluster.

- **ReplicaSet**: Maintains a stable set of replica Pods running at any given time.
  > ReplicaSet: Makes sure the right number of copies (replicas) of your pods are always running. If one goes down, it quickly brings up another to keep things running smoothly.
  - Automatically creates new Pods if existing ones are deleted.

---

### 3. **Demonstration Recap**

You created a **2-node EKS cluster** with the following steps:

#### ✅ **EKS Setup**
1. Created an EC2 instance.
2. Installed required tools:
   - `awscli`
   - `eksctl`
   - `kubectl`
3. Assigned IAM role to EC2.
4. Created cluster using:
   ```bash
   eksctl create cluster --name <cluster-name> --region <region> --node-type <instance-type>
   ```
5. Verified cluster creation using:
   ```bash
   kubectl get nodes
   ```

#### 🧩 **Cluster Structure**
- AWS manages the control plane.
- You connected via the EC2 instance to interact with the cluster.
- Pods are launched on worker nodes.

---

### 4. **Pods vs ReplicaSet**

- When a **Pod** is deleted manually, it doesn’t come back.
- When a **ReplicaSet** is used, it maintains the desired count.  
  E.g., If 3 Pods are desired and 1 is deleted, a new one is automatically created.

---

### 5. **Deploying Applications in Kubernetes**

To deploy an application:
1. **Write application code**
2. **Create Dockerfile**
3. **Build Docker image**
4. **Reference image in Kubernetes Pod config**
  > Reference image in Kubernetes Pod config means telling Kubernetes which **Docker image** to use when creating the container inside the pod. It’s like giving it the recipe to know what app to run.
5. **Deploy using `kubectl apply`**

---

### 6. **Application Upgrade Strategy**

Let’s say we have:

- **App Version 1.0**
- Code → Dockerfile → Docker Image → Pod (3 replicas)

Now, you update the code (e.g., to Version 1.1), so:
- New code → New Dockerfile → New Image → New Pod

#### ❌ **Bad Practice:**
Deleting old pods and applying new ones causes **downtime**.

---

### ✅ **Solution: Rolling Updates**

**Rolling Update** allows **zero-downtime deployments** by:
- Gradually replacing old Pods with new ones.
- Ensuring some instances of the app are always running.

---

## 🔜 What’s Next?

- Dive deeper into **Kubernetes Networking**
- Explore **etcd** in more detail
- Learn how **Rolling Updates** work with `Deployment` objects
- Possibly set up a **CI/CD pipeline** for automatic rolling updates

---

# 🚀 Kubernetes: Rolling Updates and Deployments Explained

## 📘 What is a Rolling Update?

A **Rolling Update** is a deployment strategy in Kubernetes used to upgrade applications **without any downtime**. Instead of stopping the current version and launching a new one all at once, Kubernetes **gradually replaces old Pods with new ones**, ensuring the application is always up and running.

---

## 🧠 Concept of Rolling Update

Let’s break it down with an example:

You have 3 Pods running with **application version 10**:
```
Pod-1 → v10  
Pod-2 → v10  
Pod-3 → v10
```

Now, you want to upgrade to **version 11**. Here’s how the rolling update works:

1. **Step 1:** Kubernetes launches a new Pod with **version 11**:
   ```
   Pod-1 → v10  
   Pod-2 → v10  
   Pod-3 → v10  
   Pod-4 → v11
   ```

2. **Step 2:** Once the new Pod is running, it deletes one old Pod:
   ```
   Pod-2 → v10 (deleted)  
   Remaining: Pod-1 (v10), Pod-3 (v10), Pod-4 (v11)
   ```

3. **Step 3:** It adds another new Pod with version 11:
   ```
   Pod-1 → v10  
   Pod-3 → v10  
   Pod-4 → v11  
   Pod-5 → v11
   ```

4. **Step 4:** Deletes another old Pod:
   ```
   Pod-1 → v10 (deleted)  
   Remaining: Pod-3 (v10), Pod-4 (v11), Pod-5 (v11)
   ```

5. **Step 5:** Adds one final Pod with version 11:
   ```
   Pod-3 → v10  
   Pod-4 → v11  
   Pod-5 → v11  
   Pod-6 → v11
   ```

6. **Step 6:** Deletes the last old Pod:
   ```
   Pod-3 → v10 (deleted)  
   Final Pods: Pod-4, Pod-5, Pod-6 → All running version 11 ✅
   ```

### ✅ Result:
- Your application is now fully upgraded to version 11.
- At no point was the application completely down.
- **Zero downtime**, smooth transition.

---

## ❌ Why Not Use ReplicaSet for Rolling Updates?

ReplicaSet can ensure a fixed number of Pods are running, but it doesn’t handle **upgrades**.  
If you change the image version manually:
- You must **delete** existing Pods.
- Then **recreate** new ones.
- This results in **downtime**.

> 💡 **ReplicaSet ≠ Rolling Updates**  
> For rolling updates, we use **Deployments**.

---

## ✅ Use Deployment for Rolling Updates

A **Deployment** manages ReplicaSets and enables rolling updates automatically.

Here’s a sample YAML for an NGINX deployment:

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
spec:
  replicas: 4
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
        - name: nginx
          image: nginx:latest
          ports:
            - containerPort: 80
```

### Apply the Deployment:
```bash
kubectl apply -f nginx-deployment.yaml
```

### Check Deployment Status:
```bash
kubectl get pods
kubectl get replicasets
kubectl get deployments
```

> 🎯 Kubernetes will handle:
> - Creating ReplicaSet  
> - Rolling out new Pods
  > - Rolling out new Pods means slowly replacing the old Pods with new ones, so your app keeps running smoothly without any interruptions. It's like upgrading parts of your app one by one instead of shutting everything down at once. 
> - Cleaning up old Pods  
> - Ensuring no downtime

---

## ⚙️ Behind the Scenes: How Kubernetes Creates a Pod

### Here's what happens step-by-step:

1. You run:
   ```bash
   kubectl apply -f nginx-pod.yaml
   ```
2. The YAML file is sent as an **API request** to the **Kube API Server**.
3. API Server identifies the object (`kind: Pod`) and passes it to the **Scheduler**.
4. The **Scheduler** chooses a node for the Pod based on resources.
5. The **Kubelet** on that node receives the instruction to launch the Pod.
6. **Kubelet** uses **Container Runtime** (like containerd or Docker) to pull the image and start the container.

---

## 📝 Why We Don't Create Pods Directly

When you create a Pod directly and it gets deleted:
- It **does not come back** automatically.
- There’s **no controller** managing it.

To handle that, we use **ReplicaSets** or **Deployments**, which manage Pods for us.

---

## 🔄 Summary

| Concept | Handles Pod Restart | Supports Updates | Downtime-Free |
|--------|----------------------|------------------|---------------|
| **Pod** | ❌ No                | ❌ No            | ❌ No          |
| **ReplicaSet** | ✅ Yes       | ❌ No            | ❌ No          |
| **Deployment** | ✅ Yes      | ✅ Yes           | ✅ Yes         |

---
