# Kubernetes Recap & Rolling Updates   
**Topic:** Kubernetes Architecture, Objects, EKS Setup, and Rolling Updates

---

## 📌 Topics Covered

### 1. **Kubernetes Architecture Overview**

Kubernetes has two primary layers:

#### **Control Plane**
Manages the overall cluster state.
- **kube-apiserver**: Acts as a communication hub; all components interact through it.
- **controller-manager**: Ensures that the current state matches the desired state.
- **scheduler**: Decides which pod should be placed on which node.
- **etcd**: A distributed key-value store used as Kubernetes' backing store for all cluster data.
> etcd: It's like a super-powered notepad that Kubernetes uses to keep track of everything happening in the cluster—like which pods are running, configurations, secrets, and more. It stores all this information in a safe and reliable way, so Kubernetes always knows the current state of the system.

#### **Data Plane (Worker Nodes)**
Where application workloads run.
- **kubelet**: Agent that runs on each node, communicates with the API server.
- **container runtime**: Software like Docker or containerd to run containers.
- **kube-proxy**: Manages network rules and enables communication across services and pods.
> kube-proxy: Think of it as the traffic manager for your cluster. It helps your apps (pods and services) talk to each other by setting up the right network routes and making sure requests get to the right place.

---

### 2. **Key Kubernetes Objects**

- **Pod**: The smallest deployable unit in Kubernetes, representing a single instance of a running process.
> **Pod**: It's the smallest piece you can run in Kubernetes. You can think of it like a tiny box that holds your app (or part of it) and runs it. Each pod usually runs one container, and it's where your code actually lives and works inside the cluster.

- **ReplicaSet**: Maintains a stable set of replica Pods running at any given time.
  > ReplicaSet: Makes sure the right number of copies (replicas) of your pods are always running. If one goes down, it quickly brings up another to keep things running smoothly.
  - Automatically creates new Pods if existing ones are deleted.

---

### 3. **Demonstration Recap**

You created a **2-node EKS cluster** with the following steps:

#### ✅ **EKS Setup**
1. Created an EC2 instance.
2. Installed required tools:
   - `awscli`
   - `eksctl`
   - `kubectl`
3. Assigned IAM role to EC2.
4. Created cluster using:
   ```bash
   eksctl create cluster --name <cluster-name> --region <region> --node-type <instance-type>
   ```
5. Verified cluster creation using:
   ```bash
   kubectl get nodes
   ```

#### 🧩 **Cluster Structure**
- AWS manages the control plane.
- You connected via the EC2 instance to interact with the cluster.
- Pods are launched on worker nodes.

---

### 4. **Pods vs ReplicaSet**

- When a **Pod** is deleted manually, it doesn’t come back.
- When a **ReplicaSet** is used, it maintains the desired count.  
  E.g., If 3 Pods are desired and 1 is deleted, a new one is automatically created.

---

### 5. **Deploying Applications in Kubernetes**

To deploy an application:
1. **Write application code**
2. **Create Dockerfile**
3. **Build Docker image**
4. **Reference image in Kubernetes Pod config**
  > Reference image in Kubernetes Pod config means telling Kubernetes which **Docker image** to use when creating the container inside the pod. It’s like giving it the recipe to know what app to run.
5. **Deploy using `kubectl apply`**

---

### 6. **Application Upgrade Strategy**

Let’s say we have:

- **App Version 1.0**
- Code → Dockerfile → Docker Image → Pod (3 replicas)

Now, you update the code (e.g., to Version 1.1), so:
- New code → New Dockerfile → New Image → New Pod

#### ❌ **Bad Practice:**
Deleting old pods and applying new ones causes **downtime**.

---

### ✅ **Solution: Rolling Updates**

**Rolling Update** allows **zero-downtime deployments** by:
- Gradually replacing old Pods with new ones.
- Ensuring some instances of the app are always running.

---

## 🔜 What’s Next?

- Dive deeper into **Kubernetes Networking**
- Explore **etcd** in more detail
- Learn how **Rolling Updates** work with `Deployment` objects
- Possibly set up a **CI/CD pipeline** for automatic rolling updates

---

# 🚀 Kubernetes: Rolling Updates and Deployments Explained

## 📘 What is a Rolling Update?

A **Rolling Update** is a deployment strategy in Kubernetes used to upgrade applications **without any downtime**. Instead of stopping the current version and launching a new one all at once, Kubernetes **gradually replaces old Pods with new ones**, ensuring the application is always up and running.

---

## 🧠 Concept of Rolling Update

Let’s break it down with an example:

You have 3 Pods running with **application version 10**:
```
Pod-1 → v10  
Pod-2 → v10  
Pod-3 → v10
```

Now, you want to upgrade to **version 11**. Here’s how the rolling update works:

1. **Step 1:** Kubernetes launches a new Pod with **version 11**:
   ```
   Pod-1 → v10  
   Pod-2 → v10  
   Pod-3 → v10  
   Pod-4 → v11
   ```

2. **Step 2:** Once the new Pod is running, it deletes one old Pod:
   ```
   Pod-2 → v10 (deleted)  
   Remaining: Pod-1 (v10), Pod-3 (v10), Pod-4 (v11)
   ```

3. **Step 3:** It adds another new Pod with version 11:
   ```
   Pod-1 → v10  
   Pod-3 → v10  
   Pod-4 → v11  
   Pod-5 → v11
   ```

4. **Step 4:** Deletes another old Pod:
   ```
   Pod-1 → v10 (deleted)  
   Remaining: Pod-3 (v10), Pod-4 (v11), Pod-5 (v11)
   ```

5. **Step 5:** Adds one final Pod with version 11:
   ```
   Pod-3 → v10  
   Pod-4 → v11  
   Pod-5 → v11  
   Pod-6 → v11
   ```

6. **Step 6:** Deletes the last old Pod:
   ```
   Pod-3 → v10 (deleted)  
   Final Pods: Pod-4, Pod-5, Pod-6 → All running version 11 ✅
   ```

### ✅ Result:
- Your application is now fully upgraded to version 11.
- At no point was the application completely down.
- **Zero downtime**, smooth transition.

---

## ❌ Why Not Use ReplicaSet for Rolling Updates?

ReplicaSet can ensure a fixed number of Pods are running, but it doesn’t handle **upgrades**.  
If you change the image version manually:
- You must **delete** existing Pods.
- Then **recreate** new ones.
- This results in **downtime**.

> 💡 **ReplicaSet ≠ Rolling Updates**  
> For rolling updates, we use **Deployments**.

---

## ✅ Use Deployment for Rolling Updates

A **Deployment** manages ReplicaSets and enables rolling updates automatically.

Here’s a sample YAML for an NGINX deployment:

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
spec:
  replicas: 4
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
        - name: nginx
          image: nginx:latest
          ports:
            - containerPort: 80
```

### Apply the Deployment:
```bash
kubectl apply -f nginx-deployment.yaml
```

### Check Deployment Status:
```bash
kubectl get pods
kubectl get replicasets
kubectl get deployments
```

> 🎯 Kubernetes will handle:
> - Creating ReplicaSet  
> - Rolling out new Pods -- Rolling out new Pods means slowly replacing the old Pods with new ones, so your app keeps running smoothly without any interruptions. It's like upgrading parts of your app one by one instead of shutting everything down at once. 
> - Cleaning up old Pods -- Cleaning up old Pods means removing the outdated Pods to keep things neat and make space for the new ones. 
> - Ensuring no downtime

---

## ⚙️ Behind the Scenes: How Kubernetes Creates a Pod

### Here's what happens step-by-step:

1. You run:
   ```bash
   kubectl apply -f nginx-pod.yaml
   ```
2. The YAML file is sent as an **API request** to the **Kube API Server**.
3. API Server identifies the object (`kind: Pod`) and passes it to the **Scheduler**.
4. The **Scheduler** chooses a node for the Pod based on resources.
5. The **Kubelet** on that node receives the instruction to launch the Pod.
6. **Kubelet** uses **Container Runtime** (like containerd or Docker) to pull the image and start the container.

---

## 📝 Why We Don't Create Pods Directly

When you create a Pod directly and it gets deleted:
- It **does not come back** automatically.
- There’s **no controller** managing it. -- No one is in charge of managing it.

To handle that, we use **ReplicaSets** or **Deployments**, which manage Pods for us.

---

## 🔄 Summary

| Concept | Handles Pod Restart | Supports Updates | Downtime-Free |
|--------|----------------------|------------------|---------------|
| **Pod** | ❌ No                | ❌ No            | ❌ No          |
| **ReplicaSet** | ✅ Yes       | ❌ No            | ❌ No          |
| **Deployment** | ✅ Yes      | ✅ Yes           | ✅ Yes         |

---

# Understanding Pods, ReplicaSets, and Deployments in Kubernetes

### 1. **Overview of Deployment, ReplicaSet, and Pod**
In Kubernetes, we have three important components related to running applications: **Pods**, **ReplicaSets**, and **Deployments**. Let’s look at each one and their roles in Kubernetes.

#### **Pod**
A Pod is the smallest deployable unit in Kubernetes, representing a single instance of a running process in a cluster.
> A Pod is the smallest deployable unit in Kubernetes, representing a single instance of a program or task running in a cluster.

#### **ReplicaSet**
A ReplicaSet ensures that a specified number of pod replicas are running at any given time. If any pod goes down, the ReplicaSet creates a new one to maintain the desired number of pods.

#### **Deployment**
A Deployment is a higher-level abstraction (= concept) that manages ReplicaSets and enables rolling updates to applications. Unlike ReplicaSets, Deployments offer more flexibility (= options), including the ability to handle rolling updates.

---

### 2. **Deployment Configuration** (= Setup)

Let's take a look at the deployment configuration. Below is the **nginx-deployment.yaml** that we will be using.

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
spec:
  replicas: 4
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:latest
        ports:
        - containerPort: 80
```

### Explanation of the Deployment YAML:
- `apiVersion: apps/v1`: Specifies the API version.
- `kind: Deployment`: Defines the object type as Deployment.
- `metadata`: Contains the name of the deployment (nginx-deployment).
- `spec`: Specifies the desired state:
  - `replicas: 4`: We want 4 replicas (pods) of the nginx application.
  - `selector`: Labels to match the Pods.
  - `template`: Defines the Pod template that includes the container configuration (nginx image in this case).

> Imagine you're in a library, and you want to find all the books by a particular author. 

> - **Books** are like **Pods** in Kubernetes.
> - **Labels** are like **book attributes** (e.g., author, genre, publication year).
> - The **selector** is like a **search filter** that helps you find all books by that author.

> So, when you set a selector, you're essentially saying, "I want to find all books where the author is 'John Doe'". The system will then go through all the books (pods) and bring back the ones that match the filter (the label).

> In Kubernetes, the selector helps the Deployment find and manage the Pods that match the specified labels.

---
The `template` in a Kubernetes Deployment is like a blueprint for creating Pods. Let's break down the components to make it easier to understand.

### Explanation:

- **template**: Think of it as a blueprint or a template for creating new Pods.
- **metadata**: This is like extra information or "tags" about the Pod.
- **labels**: Labels are key-value pairs that help identify and group related Pods. In this case, `app: nginx` means this Pod is labeled with "app" as the key and "nginx" as the value.

### Logical Example:

Imagine you're organizing a set of folders in a file cabinet. You have different folders for various projects, and each folder has a tag or label on it to help you find the folder later.

- Each **folder** represents a **Pod**.
- The **tag** on the folder is like a **label** in Kubernetes.

Now, suppose you are organizing folders for multiple teams, and you want to easily find all the folders related to the "nginx" project. You place a label on each folder (Pod) with the tag `app: nginx`. 

So, when you need to find all the folders related to "nginx," you can quickly look for the folders with the `app: nginx` label, just like how Kubernetes will use the label to find and manage the Pods.

In summary:
- The **template** is the blueprint for creating Pods.
- The **labels** are tags on each Pod, like “app: nginx,” to identify them and help Kubernetes group or manage them more easily.
  
---

### 3. **Creating a ReplicaSet**

Here’s an example of a ReplicaSet configuration:

```yaml
apiVersion: apps/v1
kind: ReplicaSet
metadata:
  name: nginx-replicaset
  labels:
    app: nginx
spec:
  replicas: 3  
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:latest  
        ports:
        - containerPort: 80
```

### Explanation of the ReplicaSet YAML:
- `apiVersion: apps/v1`: Specifies the API version.
- `kind: ReplicaSet`: Defines the object type as ReplicaSet.
- `metadata`: Contains the name and labels.
- `spec`: Specifies the desired state:
  - `replicas: 3`: We want 3 replicas of the nginx pod.
  - `selector`: Labels to match the Pods.
  - `template`: Defines the Pod template (same as in the Deployment file).

---

### 4. **Pod Configuration Example**

Here’s an example of a basic Pod configuration:

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: nginx-pod
spec:
  containers:
  - name: nginx
    image: nginx:latest
    ports:
    - containerPort: 80
```

### Explanation of the Pod YAML:
- `apiVersion: v1`: Specifies the API version.
- `kind: Pod`: Defines the object type as Pod.
- `metadata`: Contains the name of the Pod (nginx-pod).
- `spec`: Defines the container running inside the Pod (nginx image in this case).

---

### 5. **How to Create and Manage Pods**

#### **Create a Pod**:
To create a pod using the `nginx-pod.yaml` file:

```bash
kubectl apply -f nginx-pod.yaml
```

This command will create the Pod. You can verify its creation by running:

```bash
kubectl get pods
```

#### **Delete a Pod**:
If you delete the Pod, it will not be recreated automatically unless it is managed by a ReplicaSet or Deployment:

```bash
kubectl delete pod nginx-pod
```

You will notice that the Pod does not automatically come back if it was created directly without any controller managing it.

#### **Delete a Pod Managed by a ReplicaSet**:
If you delete a Pod that is part of a ReplicaSet, it will automatically be recreated. This is because the ReplicaSet ensures the desired number of pods is maintained.

---

### 6. **Why Use Deployments Instead of Pods Directly?**

When using Kubernetes, it is recommended to use **Deployments** instead of creating Pods directly for several reasons:

1. **Automatic Management**: A Deployment will automatically manage the ReplicaSets, ensuring the desired state is always maintained. If you delete a Pod, it will be recreated.
   
2. **Rolling Updates**: Deployments offer the feature of rolling updates, which allow you to gradually update your application without any downtime.

3. **Scalability**: Deployments and ReplicaSets allow for easy scaling of your application by increasing or decreasing the number of replicas.

---

### 7. **Checking the Deployment and Pods**

To check the current state of your Deployments and Pods, you can use the following commands:

```bash
kubectl get deployments
kubectl get pods
```

If you want more details about a specific Deployment, you can use the `describe` command:

```bash
kubectl describe deployment nginx-deployment
```

---

### 8. **Summary of Key Concepts**

- **Pod**: The smallest unit in Kubernetes that runs a container.
- **ReplicaSet**: Ensures the desired number of Pods are always running.
- **Deployment**: Manages ReplicaSets, provides rolling updates, and simplifies the management of Pods.

In Kubernetes, we avoid creating Pods directly and instead use Deployments to leverage the benefits of rolling updates and automatic management.

---

### 9. **Conclusion**

By using **Deployments** in Kubernetes, we can take advantage of automatic rolling updates, replica management, and scalability features, making it easier to manage our application lifecycle without causing downtime. Instead of manually managing Pods or ReplicaSets, Kubernetes handles everything for us when we use Deployments.

---

# 📘 Kubernetes Deployment and Rolling Update Strategy (EKS Example)

This document explains how **Kubernetes Deployments**, **ReplicaSets**, and **Pods** interact with each other, particularly in **Amazon EKS (Elastic Kubernetes Service)**. We’ll look into how information is fetched (= gathered) using `kubectl`, how updates are managed using the **rolling update strategy**, and how the **etcd database** plays a critical role in storing cluster state.

---

## 🧠 What is `etcd`?

- `etcd` is a **distributed key-value store** that acts as the **database of Kubernetes**.
- It stores **all cluster data**:
  - Nodes
  - Pods
  - Deployments
  - ReplicaSets
  - Configuration details
- Every time you run a `kubectl` command, the data comes from the `etcd` store.

---

## 🔍 Describing a Deployment

### Command:
```bash
kubectl describe deployments.apps nginx-deployment
```

### Output Summary:
```yaml
Name:                   nginx-deployment
Namespace:              default
Replicas:               4 desired | 4 available
StrategyType:           RollingUpdate
RollingUpdateStrategy:  25% max unavailable, 25% max surge
Containers:
  - Image: nginx:latest
```

### Key Points:
- **Name**: Defined in your manifest YAML (`metadata.name`) -- ( = "Name: Defined in your configuration file (metadata.name).")
- **Namespace**: Kubernetes namespace where this deployment exists
- **Replicas**: Desired and actual pod counts
- **StrategyType**: `RollingUpdate` used for zero-downtime updates
- **Image**: The container image used (`nginx:latest`)

> 📌 The `Deployment` object manages updates using the **RollingUpdate** strategy.

---

## 🔁 Rolling Update Strategy

### From the Deployment:
```yaml
strategy:
  type: RollingUpdate
  rollingUpdate:
    maxUnavailable: 25%
    maxSurge: 25%
```

- **maxUnavailable**: Max pods that can be unavailable during the update
- **maxSurge**: Max extra pods that can be created during the update
- Ensures **zero downtime deployments**

---

## 📦 Understanding ReplicaSets

### Command:
```bash
kubectl describe replicaset nginx-deployment-576c6b7b6
```

### Key Differences from Deployment:
- **No Rolling Update Strategy**
- **Controls the pods directly**
- Follows instructions from its parent Deployment

### Status Info:
```yaml
Replicas: 4 current | 4 desired
```

> 🧩 If `current` = `desired`, no action is taken. If there’s a mismatch, pods are created or terminated to match.

---

## ⚙️ Deployment → ReplicaSet → Pods

### Flow:
1. **Deployment** creates a **ReplicaSet**
2. **ReplicaSet** manages **Pods**

### Naming Convention:
- **Deployment Name**: `nginx-deployment`
- **ReplicaSet Name**: `nginx-deployment-576c6b7b6`
- **Pod Name**: `nginx-deployment-576c6b7b6-abcde`

This helps in identifying which pod belongs to which ReplicaSet and Deployment.

---

## 🔄 Recreating Pods

### Deleting Pods:
```bash
kubectl delete pod <pod-name>
```

> Pods will be **automatically recreated** by the ReplicaSet to maintain desired state.

### Deleting Deployment:
```bash
kubectl delete deployment nginx-deployment
```

> This will clean up the **Deployment**, **ReplicaSet**, and **Pods**.

---

## 🧪 Rolling Update Example (Upgrade)

You can simulate a rolling update by editing the image version in your Deployment YAML:
> "You can test a rolling update by changing the image version in your Deployment file."
> "To see how a rolling update works, change the image version in your Deployment file."

```yaml
containers:
- name: nginx
  image: nginx:1.25.1  # Newer version
```

Then apply the updated YAML:
```bash
kubectl apply -f nginx-deployment.yaml
```

Kubernetes will:
- Launch new pods with the updated image
- Terminate old pods
- Ensure service availability during update

---

## 🛠️ Tools for Managing YAML Files

You don’t always have to write Kubernetes YAMLs manually. Here are some helpful tools:
- **Kustomize** (built-in with kubectl)
- **Helm** (templating and package manager for K8s)
- **Kompose** (convert docker-compose to Kubernetes YAML)
- Online generators like:
  - [KubeYAML](https://kubeyaml.com/)
  - [K8s YAML Generator by Codefresh](https://codefresh.io/kubernetes-yaml-generator/)

---

## ✅ Summary

| Concept        | Object        | Description |
|----------------|---------------|-------------|
| Deployment     | High-level object | Manages updates, defines strategy |
| ReplicaSet     | Mid-level     | Ensures pod count matches desired |
| Pod            | Lowest-level  | Container(s) that run the app |
| etcd           | Database      | Stores the state of the cluster |
| Rolling Update | Strategy      | Enables zero-downtime updates |

---
