### Kubernetes Networking and Service Discovery

In this section, we’re going to explore **how Kubernetes handles networking**, with a key focus on **service discovery**. If you’ve previously worked with Docker Swarm, you may already be familiar with how service discovery functions in that environment. Kubernetes uses a **very similar approach**, so you'll likely recognize some patterns. However, if you're new to this concept, don't worry—this section assumes no prior knowledge and we’ll walk through everything from the ground up.

---

### Why Network Containers?

Let’s begin with a basic question: **Why do we need to network containers together?**

Imagine we have deployed an application—say, a Java application—in a container. This application needs to persist data in a database. Now, if you've taken my Docker course, you'll recall that **embedding the database inside the same container as the application is not recommended**. Even if you haven’t taken that course, the key point is:

> **Docker containers are designed to run a single service.**

While it is technically possible to expose multiple services from one container, it’s a complex and generally discouraged practice. Instead, we deploy the application and the database in **separate containers**.

For example:

* One container runs the Java application.
* A second container runs a MySQL database.

Now, we need these containers to **communicate with each other over the network**.

---

### Networking Within a Pod

In Kubernetes, **if both containers are placed within the same Pod**, networking is very straightforward. They can communicate via `localhost`, since all containers in the same pod share the same network namespace.

For example:

* The Java app can connect to the MySQL service using `localhost:3306`.

However, I **do not recommend running multiple containers in a single pod**, unless you have a very specific reason. Here’s why:

* Troubleshooting becomes harder. If the pod fails, it's difficult to tell if the failure is due to the application container or the database container.
* Managing and scaling the application becomes more complex.

Instead, best practice is to **deploy each service in a separate pod**.

---

### Services and DNS-Based Discovery

When using separate pods, Kubernetes enables inter-pod communication through **Services**. Each pod is exposed via a Kubernetes **Service**, which gets assigned a **private IP address** within the cluster.

Here’s the challenge:

* These IP addresses are **dynamically assigned**.
* They can **change** when the cluster is restarted or rescheduled.

So, how can our application reliably find and connect to the database?

This is where **Kubernetes Service Discovery** comes in.

Kubernetes runs a **built-in DNS service** called `kube-dns`. This DNS service automatically:

* Maps **Service names** to their respective IP addresses.
* Handles **dynamic updates** when services or pods change.

So, in your Java application, you can simply connect to the database using:

```text
jdbc:mysql://database:3306
```

Where `database` is the **name of the Kubernetes service** exposing the MySQL pod.

Behind the scenes, Kubernetes:

* Performs a DNS lookup on the name `database`.
* Resolves it to the correct internal IP.
* Routes the traffic to the right pod.

This process is completely managed by Kubernetes—you **don’t need to configure the DNS service manually**.

---

### kube-dns and the DNS Pod

The **`kube-dns` service** is automatically created in your cluster. It typically runs inside a pod called `kube-dns`, which itself contains **multiple containers** (though this is an implementation detail you usually don’t need to worry about).

> As long as your services are properly defined, Kubernetes handles all DNS resolution behind the scenes.

---

### But Why Haven’t We Seen kube-dns Yet?

If you run:

```bash
kubectl get all
```

You might not see any reference to `kube-dns`. That’s because it’s running in a **different namespace**—a concept we haven’t covered yet.

Namespaces in Kubernetes allow you to group and isolate resources. The `kube-dns` service runs in the `kube-system` namespace, not the default one.

---

### What’s Next?

In the next section, we’ll explore **Kubernetes Namespaces**—a simple but powerful concept that helps organize and manage resources in your cluster. Once you understand namespaces, we’ll return to the topic of networking and **see service discovery in action in the terminal**.

See you in the next video!

---
